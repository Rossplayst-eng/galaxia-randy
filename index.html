<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Para Randy üíô</title>

<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; }
  canvas { display:block; width:100%; height:100%; }

  .title{
    position:fixed; top:18px; left:0; right:0;
    text-align:center; z-index:10; pointer-events:none;
    font-family:"Pacifico", cursive;
    font-size:44px;
    color:#ff66c9;
    text-shadow:0 0 12px rgba(255,80,200,.55), 0 0 40px rgba(255,0,170,.25);
  }
  .sub{
    position:fixed; top:82px; left:0; right:0;
    text-align:center; z-index:10; pointer-events:none;
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
    font-size:16px; letter-spacing:.2px;
    color:rgba(255,255,255,.88);
    text-shadow:0 0 12px rgba(0,0,0,.65);
  }
  .sub b{ color:#7bd3ff; }
</style>
</head>

<body>
  <div class="title">Feliz San Valent√≠n ‚ù§Ô∏è</div>
  <div class="sub">Te amo hasta el infinito y m√°s all√° ‚àû ‚Äî <b>Para Randy üíô‚ú®</b></div>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.min(2, devicePixelRatio || 1);
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  addEventListener("resize", resize);
  resize();

  // ===== CONFIG =====
  const STICKER_SRC = "IMG_4079.png"; // <-- cambia si tu archivo tiene otro nombre

  const MAIN_PHRASE = "Te amo hasta el infinito y m√°s all√° üíô";
  const NAMES = ["Randy"];
  const PHRASES = [
    "Mi cielo üí´",
    "Mi infinito ‚ôæÔ∏è",
    "Mi mundo entero üåç",
    "Mi ni√±o üß∏",
    "Mi chiquito hermoso ü•π",
    "Mi rey üëë",
    "Mi todo üíû",
    "Hasta el infinito y m√°s all√° üöÄ",
    "Mi desastre fav üòà",
    "Te amo üíô"
  ];

  // Visual tuning (sin saturaci√≥n)
  const STAR_COUNT = 900;
  const FLOOR_POINTS = 2400;
  const FLOOR_TEXTS = 38;

  // ===== UTIL =====
  const rnd = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));

  // ===== STARFIELD =====
  const stars = Array.from({length: STAR_COUNT}, () => ({
    x: Math.random(),
    y: Math.random(),
    r: rnd(0.3, 1.4),
    a: rnd(0.2, 0.9),
    tw: rnd(0.002, 0.01)
  }));

  // ===== 3D-ish projection =====
  // camera
  const cam = {
    fov: 520,
    y: 1.25,
    z: -2.0
  };

  // world -> screen with simple perspective
  function project(x, y, z){
    // camera transform (only translate + slight raise)
    const cz = z - cam.z;
    const cy = y - cam.y;

    const s = cam.fov / (cz + 6.0);
    return {
      x: (W/2) + x*s,
      y: (H*0.78) + cy*s,
      s
    };
  }

  // ===== FLOOR GALAXY (points) =====
  // Points are on a "floor" plane y=0, spread in x and z
  const floor = Array.from({length: FLOOR_POINTS}, () => ({
    x: rnd(-8.5, 8.5),
    z: rnd(1.0, 22.0),
    r: rnd(0.4, 1.2),
    hue: rnd(190, 320) // bluish-pinkish range
  }));

  // ===== FLOATING TEXTS ON FLOOR =====
  const floorTexts = Array.from({length: FLOOR_TEXTS}, () => ({
    x: rnd(-7.5, 7.5),
    z: rnd(2.5, 18.0),
    text: PHRASES[Math.floor(Math.random()*PHRASES.length)],
    alpha: rnd(0.35, 0.8),
    wob: rnd(0, Math.PI*2)
  }));

  // ===== CENTER ORBIT RING + GLOW =====
  // ring center in world coords
  const ring = {
    x: 0,
    z: 6.2,
    y: -0.05,
    rx: 3.3,  // ring radius (x axis)
    rz: 1.2   // ring radius (z axis -> ellipse in perspective)
  };

  // ===== ORBITING TEXTS AROUND RING =====
  const orbitTexts = Array.from({length: 18}, (_,i)=>({
    t: (i/18)*Math.PI*2,
    text: (i%3===0 ? MAIN_PHRASE : PHRASES[Math.floor(Math.random()*PHRASES.length)]),
    hue: rnd(285, 325),
    size: rnd(14, 22)
  }));

  // ===== STICKERS ORBITING =====
  const stickerImg = new Image();
  stickerImg.src = STICKER_SRC;

  const stickers = Array.from({length: 14}, (_,i)=>({
    t: (i/14)*Math.PI*2,
    spin: rnd(-0.7, 0.7),
    bob: rnd(0, Math.PI*2),
    scale: rnd(0.7, 1.15)
  }));

  // ===== TIMING =====
  let time = 0;

  // ===== DRAW HELPERS =====
  function drawGlowEllipse(cx, cy, rx, ry, color, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    const g = ctx.createRadialGradient(cx, cy, 1, cx, cy, Math.max(rx, ry)*1.25);
    g.addColorStop(0, color);
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(cx, cy, rx*1.25, ry*1.25, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function softText(text, x, y, sizePx, color, glowAlpha){
    ctx.save();
    ctx.font = `${sizePx}px Pacifico, system-ui`;
    ctx.fillStyle = color;
    ctx.shadowColor = color;
    ctx.shadowBlur = 18 * glowAlpha;
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  // ===== MAIN RENDER =====
  function render(){
    time += 0.012;

    // background gradient (subtle)
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    const bg = ctx.createRadialGradient(W*0.5, H*0.35, 10, W*0.5, H*0.5, Math.max(W,H));
    bg.addColorStop(0, "rgba(50,0,90,0.55)");
    bg.addColorStop(0.45, "rgba(10,0,30,0.45)");
    bg.addColorStop(1, "rgba(0,0,0,1)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);

    // stars
    for(const s of stars){
      const tw = 0.35 + 0.65*Math.abs(Math.sin(time*2.0*s.tw + s.x*10));
      ctx.globalAlpha = s.a * tw;
      const px = s.x * W;
      const py = s.y * H;
      ctx.fillStyle = "#fff";
      ctx.fillRect(px, py, s.r*DPR, s.r*DPR);
    }
    ctx.globalAlpha = 1;

    // slow rotation like video
    const rot = time * 0.28;

    // FLOOR points (galaxy dust)
    // Draw far -> near by sorting on z (simple)
    // (no heavy sort each frame: approximate by grouping)
    for(const p of floor){
      const xr = p.x*Math.cos(rot) - p.z*Math.sin(rot);
      const zr = p.x*Math.sin(rot) + p.z*Math.cos(rot);

      const pr = project(xr, 0, zr);
      if(pr.s < 0.08) continue;

      const a = clamp((zr/22), 0.12, 0.95);
      ctx.globalAlpha = a;

      // soft colored dust
      const size = p.r * pr.s * 3.0;
      ctx.fillStyle = `hsla(${p.hue}, 90%, 75%, ${0.22})`;
      ctx.beginPath();
      ctx.arc(pr.x, pr.y, size*0.9, 0, Math.PI*2);
      ctx.fill();

      // white sparkle
      ctx.fillStyle = `rgba(255,255,255,${0.45})`;
      ctx.fillRect(pr.x, pr.y, Math.max(1.0, size*0.35), Math.max(1.0, size*0.35));
    }
    ctx.globalAlpha = 1;

    // FLOOR neon texts (subtle)
    ctx.save();
    for(const t of floorTexts){
      const wob = Math.sin(time*0.9 + t.wob) * 0.18;

      const xr = t.x*Math.cos(rot) - t.z*Math.sin(rot);
      const zr = t.x*Math.sin(rot) + t.z*Math.cos(rot);

      const pr = project(xr, 0, zr);
      if(pr.s < 0.12) continue;

      const size = clamp(22*pr.s, 10, 22);
      ctx.globalAlpha = t.alpha * clamp(pr.s*1.4, 0.2, 0.95);

      ctx.font = `${size}px Pacifico, system-ui`;
      ctx.fillStyle = "rgba(255,110,210,0.95)";
      ctx.shadowColor = "rgba(255,80,200,0.7)";
      ctx.shadowBlur = 18 * pr.s;

      // slightly angled feel (fake): small y wob
      ctx.fillText(t.text, pr.x - (60*pr.s), pr.y + wob*18*DPR);
    }
    ctx.restore();
    ctx.globalAlpha = 1;

    // CENTER RING (glow + stroke)
    const center = project(ring.x, ring.y, ring.z);
    const ringRx = 210 * center.s;
    const ringRy = 72 * center.s;

    // big glow pool
    drawGlowEllipse(center.x, center.y, ringRx*1.35, ringRy*1.35, "rgba(255,90,210,0.55)", 0.9);
    // inner glow
    drawGlowEllipse(center.x, center.y, ringRx*0.75, ringRy*0.75, "rgba(255,220,255,0.45)", 0.7);

    // ring stroke (neon)
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.lineWidth = 6 * center.s;
    ctx.strokeStyle = "rgba(255,80,210,0.85)";
    ctx.shadowColor = "rgba(255,80,210,0.9)";
    ctx.shadowBlur = 28 * center.s;
    ctx.beginPath();
    ctx.ellipse(center.x, center.y, ringRx, ringRy, 0, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // Orbiting texts around ring (like phrases in the video)
    ctx.save();
    for(const o of orbitTexts){
      const a = o.t + time*0.35;
      // orbit in world around ring center
      const ox = ring.x + Math.cos(a) * 3.9;
      const oz = ring.z + Math.sin(a) * 1.7; // ellipse
      const oy = -0.05 + Math.sin(a*2 + time)*0.12;

      const pr = project(ox, oy, oz);
      if(pr.s < 0.1) continue;

      const size = clamp(o.size*pr.s, 10, 22);
      const alpha = clamp(pr.s*1.3, 0.25, 0.95);

      ctx.globalAlpha = alpha;
      ctx.font = `${size}px Pacifico, system-ui`;
      ctx.fillStyle = "rgba(255,120,220,0.95)";
      ctx.shadowColor = "rgba(255,90,210,0.85)";
      ctx.shadowBlur = 20 * pr.s;

      ctx.fillText(o.text, pr.x - 80*pr.s, pr.y);
    }
    ctx.restore();
    ctx.globalAlpha = 1;

    // Stickers orbitando (rotan + flotan)
    if(stickerImg.complete){
      // draw further stickers first for depth
      const sorted = stickers
        .map(s=>{
          const a = s.t + time*0.42;
          const x = ring.x + Math.cos(a) * 4.6;
          const z = ring.z + Math.sin(a) * 2.2;
          const y = -0.22 + Math.sin(time*1.1 + s.bob)*0.25;
          return {s, a, x, y, z};
        })
        .sort((A,B)=> A.z - B.z);

      for(const it of sorted){
        const pr = project(it.x, it.y, it.z);
        if(pr.s < 0.08) continue;

        const base = 92 * pr.s * it.s.scale;
        const rotSticker = (it.a * 0.5) + time*it.s.spin;

        ctx.save();
        ctx.globalAlpha = clamp(pr.s*1.3, 0.25, 0.95);
        ctx.translate(pr.x, pr.y);
        ctx.rotate(rotSticker);

        // soft shadow glow
        ctx.shadowColor = "rgba(255,90,210,0.25)";
        ctx.shadowBlur = 22 * pr.s;

        ctx.drawImage(stickerImg, -base/2, -base/2, base, base);
        ctx.restore();
      }
    } else {
      // hint while loading
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "white";
      ctx.font = `${14*DPR}px system-ui`;
      ctx.fillText("Cargando sticker...", 20*DPR, (H-20*DPR));
      ctx.restore();
    }

    // subtle vignette
    ctx.save();
    const vg = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.35, W/2, H/2, Math.max(W,H)*0.65);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    requestAnimationFrame(render);
  }

  render();
})();
</script>
</body>
</html>
