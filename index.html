<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Para Randy üíô</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    canvas{display:block;width:100vw;height:100vh}
    .text{
      position:fixed;left:0;right:0;bottom:28px;z-index:5;
      display:flex;flex-direction:column;align-items:center;gap:8px;
      pointer-events:none;text-align:center;padding:0 18px;
    }
    .title{
      color:rgba(255,255,255,.92);
      font-size:18px;font-weight:700;
      letter-spacing:.2px;
      text-shadow:0 2px 18px rgba(0,0,0,.85);
    }
    .sub{
      color:rgba(140,180,255,.92);
      font-size:13px;font-weight:600;
      text-shadow:0 2px 18px rgba(0,0,0,.85);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="text">
    <div class="title">Randy</div>
    <div class="sub">Te amo hasta el infinito y m√°s all√° ‚ôæÔ∏èüíô</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, devicePixelRatio || 1));
    W = canvas.width  = Math.floor(innerWidth * DPR);
    H = canvas.height = Math.floor(innerHeight * DPR);
  }
  addEventListener("resize", resize);
  resize();

  const rnd = (a,b)=>a+Math.random()*(b-a);

  // Fondo de estrellas (suave, no cargado)
  const STAR_COUNT = 420;
  const stars = Array.from({length: STAR_COUNT}, () => ({
    x: Math.random(),
    y: Math.random(),
    r: rnd(0.6, 1.6),
    a: rnd(0.08, 0.45),
    ph: rnd(0, Math.PI*2),
    sp: rnd(0.6, 1.2)
  }));

  // ====== Constelaci√≥n: "R" + coraz√≥n ======
  // Est√° hecha con puntos (estrellas grandes) y l√≠neas finas.
  // Coordenadas relativas en un cuadro [-1..1] que luego se escala al centro.
  function makeRShape(){
    // Una R simple: palo + curva + pierna diagonal
    const pts = [];
    // palo vertical
    for(let i=0;i<10;i++) pts.push([-0.55, -0.65 + i*(1.3/9)]);
    // curva superior (semi-oval)
    pts.push([-0.25, -0.65]);
    pts.push([-0.05, -0.55]);
    pts.push([ 0.05, -0.35]);
    pts.push([-0.05, -0.15]);
    pts.push([-0.25, -0.05]);
    pts.push([-0.55, -0.05]);
    // pierna diagonal
    pts.push([-0.35,  0.10]);
    pts.push([-0.15,  0.35]);
    pts.push([ 0.05,  0.65]);
    return pts;
  }

  function makeHeartShape(){
    // Coraz√≥n minimal con 12 puntos
    return [
      [0.35,-0.10],[0.52,-0.22],[0.68,-0.14],[0.72,0.02],
      [0.62,0.18],[0.48,0.30],[0.35,0.42],[0.22,0.30],
      [0.08,0.18],[-0.02,0.02],[0.02,-0.14],[0.18,-0.22]
    ];
  }

  const R_POINTS = makeRShape();
  const HEART_POINTS = makeHeartShape();

  // Convertimos esos puntos a estrellas ‚Äúconstellation‚Äù
  function buildConstellation(){
    const cx = W/2;
    const cy = H*0.46;

    const scale = Math.min(W,H) * 0.22; // tama√±o general (minimal)
    const gap = Math.min(W,H) * 0.12;   // distancia entre R y coraz√≥n

    const pts = [];

    // R a la izquierda
    for(const [x,y] of R_POINTS){
      pts.push({
        x: cx + (x*scale) - gap,
        y: cy + (y*scale),
        r: rnd(1.6, 2.4)*DPR,
        tw: rnd(0, Math.PI*2),
        a: rnd(0.55, 0.95),
        hue: "rgba(255,255,255,"
      });
    }

    // Coraz√≥n a la derecha (con un toque azul)
    for(const [x,y] of HEART_POINTS){
      pts.push({
        x: cx + (x*scale) + gap,
        y: cy + (y*scale),
        r: rnd(1.6, 2.6)*DPR,
        tw: rnd(0, Math.PI*2),
        a: rnd(0.60, 0.98),
        hue: "rgba(140,180,255,"
      });
    }

    // Definimos conexiones (l√≠neas) por cercan√≠a (pero pocas)
    const edges = [];
    const maxDist = scale*0.35;
    for(let i=0;i<pts.length;i++){
      for(let j=i+1;j<pts.length;j++){
        const dx = pts[i].x-pts[j].x;
        const dy = pts[i].y-pts[j].y;
        const d = Math.hypot(dx,dy);
        if(d < maxDist){
          // No saturar: solo algunas l√≠neas
          if(Math.random() < 0.22){
            edges.push([i,j, d]);
          }
        }
      }
    }
    return {pts, edges};
  }

  let constellation = buildConstellation();
  addEventListener("resize", () => { resize(); constellation = buildConstellation(); });

  let t = 0;

  function draw(){
    t += 0.012;

    // Fondo (suave)
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(0,0,W,H);

    // Estrellas de fondo
    for(const s of stars){
      const tw = (Math.sin(t*s.sp + s.ph)*0.5+0.5);
      ctx.globalAlpha = s.a*(0.35+tw*0.8);
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.fillRect(s.x*W, s.y*H, s.r*DPR, s.r*DPR);
    }
    ctx.globalAlpha = 1;

    // L√≠neas constelaci√≥n (muy finas, pocas)
    ctx.lineWidth = 1*DPR;
    for(const [i,j,d] of constellation.edges){
      const a = 0.10 + 0.22*(1 - d/(Math.min(W,H)*0.22));
      ctx.strokeStyle = `rgba(140,180,255,${a})`;
      ctx.beginPath();
      ctx.moveTo(constellation.pts[i].x, constellation.pts[i].y);
      ctx.lineTo(constellation.pts[j].x, constellation.pts[j].y);
      ctx.stroke();
    }

    // Estrellas de la constelaci√≥n (brillan suave)
    for(const p of constellation.pts){
      const tw = (Math.sin(t*1.2 + p.tw)*0.5+0.5);
      const alpha = p.a*(0.55 + tw*0.45);

      // glow suave
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = alpha*0.22;
      ctx.fillStyle = p.hue + "1)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r*4.2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // n√∫cleo
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.hue + "1)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    requestAnimationFrame(draw);
  }

  // Inicio
  ctx.fillStyle = "black";
  ctx.fillRect(0,0,W,H);
  draw();
})();
</script>
</body>
</html>
